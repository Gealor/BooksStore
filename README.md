# Что сделать в этой ветке?
1. Рефакторинг тестов и аутентификации/авторизации
2. Подключение и работа с Redis

# Работа с логгерами uvicorn
https://stackoverflow.com/questions/77001129/how-to-configure-fastapi-logging-so-that-it-works-both-with-uvicorn-locally-and

Для запуска тестов пропишите в папке проекта(где находятся src и tests) команду pytest
# Инструкция по запуску

## 1. Установите poetry с официального сайта
https://python-poetry.org/docs/#installing-with-the-official-installer

## 2. Создание виртуального окружения
В корневой папке проекта пропишите команду 

```
python -m venv <имя_виртуального_окружения> 
```

Чтобы войти в терминале в виртуальное окружение пропишите в консоли (в папке проекта)

```
<имя вашего окружения>\Scripts\activate
```
## 3. Установите все зависимости внутри виртуального окружения
Внутри созданного виртуального окружения пропишите команды в следующем порядке:

```
poetry lock
poetry install
```

## 4. Создайте файлы переменных окружения .env и .env.mock
В папке src создайте два файла .env и .env.mock со следующим содержимым:

```
# .env
APP_CONFIG__DB__USER = имя пользователя в СУБД, под которым приложение будет подключаться
APP_CONFIG__DB__PASSWORD = пароль этого пользователя
APP_CONFIG__DB__HOST = адрес сервера СУБД (например, 127.0.0.1)
APP_CONFIG__DB__PORT = порт, на котором СУБД принимает подключения (по умолчанию для PostgreSQL — 5432)
APP_CONFIG__DB__NAME = название базы данных, к которой следует подключиться (или которую нужно создать)
```

```
APP_CONFIG__DB_MOCK__USER = имя пользователя в СУБД, под которым приложение будет подключаться
APP_CONFIG__DB_MOCK__PASSWORD = пароль этого пользователя
APP_CONFIG__DB_MOCK__HOST = адрес сервера СУБД (например, 127.0.0.1)
APP_CONFIG__DB_MOCK__PORT = порт, на котором СУБД принимает подключения (по умолчанию для PostgreSQL — 5432)
APP_CONFIG__DB_MOCK__NAME = название базы данных, к которой следует подключиться (или которую нужно создать)

APP_CONFIG__DB_MOCK__ECHO = 0
APP_CONFIG__DB_MOCK__ECHO_POOL = 0
APP_CONFIG__DB_MOCK__POOL_SIZE = 50
APP_CONFIG__DB_MOCK__MAX_OVERFLOW = 10
```

## 5. Создайте тестовую и основную базы данных
В папке src запустите скрипты create_main_database.py и create_mock_database.py. Обратите внимание, что в скриптах осуществляется подключение к базе данных с именем postgres, это база данных по умолчанию в PostgreSQL, но вы можете указать любую из существующих.

## 6. Создание таблиц и первая ревизия
В терминале перейдите в папку src (где лежит файл alembic.ini) и припишите следующую команду

```
alembic revision --autogenerate -m "имя ревизии"
```
После этого в папке src\alembic\versions создастся файл с соответствующим названием. Чтобы применить ревизию пропишите команду(так же в папке, где лежит alembic.ini):
```
alembic upgrade head
```

## 7. Выпуск сертификатов для JWT
В папке src/auth создайте папку certs/, перейдите в терминале в эту папку и пропишите команды, которые лежат в src/auth/README.md.

    ВНИМАНИЕ: Не делитесь ни с кем приватным ключом!!!

# Структура проекта
Проект разделен на два модуля: tests и src.

В tests расположены тесты для crud операций и API.

В src расположена основная логика приложения:
> main.py - основной входной файл приложения, к которому подключаются все роутеры из папки api

> repositories/ - папка для репозиториев(для доступа к crud функционалу) различных моделей

> services/ - папка которые хранит сервисы для каждой сущности, для реализации бизнес логики

> core/ - важная папка, содержащая файл конфигурации config.py, где собраны все настройки приложения, папку models/ с описанием моделей таблиц, а также schemas/ содержащая различные Pydantic схемы для response_model в ручках (которые лежат в api/)

> auth/ - папка, в которой будут лежать сертификаты(ключи) для jwt-аутентификации, а также инструменты для шифрования/дешифрования токенов, хэширования паролей и проверки пароля и хэша (используется библиотека bcrypt).

> api/ - папка, где лежат эндпоинты (вьюшки, ручки) для самого API. Для каждой сушности свой пакет, со своим роутером. В самом api/\_\_init\_\_.py лежит главный роутер, которые затем подключается к основному файлу приложения.

# Структура базы данных
В папке core/models вы можете ознакомиться с тремя моделями таблиц: users, books и borrowed_books.

Таблица borrowed_books служит связующей таблицей между users и books, т.о. реализуется связь многие-ко-многим, т.к. книга может быть у нескольких пользователей, а у книги может быть несколько пользователей соответственно, тут я имею ввиду что у каждой записи в таблице books есть количество экземпляров этой книги, т.е. одной книгой может владеть несколько пользователей.

Самое сложное было продумать каскадное удаление записей. Тут можно было реализовать по разному, но я руководствовался следующим правилом: если книга удаляется из таблицы, то она больше не нужна библиотеке и потому нам уже неважно, какой пользователь ее взял. Т.е. когда удаляется книга, удаляются и соответствующие записи с id этой книги из borrowed_books.

Знаю, что это может быть глупой логикой, но на момент разработки я посчитал это самым логическим вариантом.

# Аутентификация и авторизация
Выше я уже описал процесс выпуска публичного и приватного ключей для JWT-аутентификации. Здесь я расскажу подробно о реализации аутентификации.

В файле src/auth/tools.py содержатся инструменты для шифрования/дешифрования токена, хэширования паролей и их сравнения.

## Немного про библиотеки
Выбор библиотеки для выпуска JWT токенов был между FastAPI JWT Auth, python-jose и PyJWT.

FastAPI-JWT-Auth отпал сразу, т.к. его поддержка закончилась уже в 2020 году.
python-jose был очень хорошим вариантом, но в итоге я выбрал PyJWT, т.к. python-jose основан на этой библиотеке и содержит необходимый минимум (чтобы не разбегались глаза).

С выбором библиотеки для хэширования паролей проблем не было и выбор сразу пал на bcrypt.
##

Основые ручки для регистрации(создания пользователя) и логина реализованы в папке src/api/auth, там же лежат вспомогательные зависимости в папке tools. 

Я реализовал два вида аутентификации:

1. На основе OAuth2PasswordBearer, т.к. эта зависимость предоставляет удобную документацию в Swagger для аутентификации с помощью username и password (не пугайтесь что указано username, в приложении в качестве username выступает email, т.к. используется OAuth2PasswordRequestForm в качестве зависимости)

2. На основе HTTPBearer, эта зависимость уже не предоставляет удобной и привычной формы в виде логина/пароля, но зато можно реализовать refresh-токен для выпуска нового access-токена

## Какие эндпоинты защищены и почему?
1. /api/auth/refresh - эндпоинт для выпуска нового access-токена на основе refresh-токена. Защищен по понятным причинам, т.к. у невошедшего пользователя нет ни access-токена, ни refresh-токена.

2. /api/users/me - тестовый эндпоинт для проверки защищенности, выводит имя и почту вошедшего пользователя. Защищен для вывода информации о вошедшем пользователе.

3. /api/users/my-books - энпоинт для получения списка НЕ ВОЗВРАЩЕННЫХ книг на данный момент, который взял пользователь. Защищено для вывода информации только о книгах взятых авторизованным пользователем.

4. /api/users/history - эндпоинт для получения истории всех взятых и возвращенных пользователем книг. Аналогично ручке 3.

5. /api/users/delete-user - тестовый эндпоинт для удаления пользователя с любым id кроме своего (по поводу этой ручки есть дополнительная фича, которую я изложу ниже). Защищен, чтобы обезопасить данные, от неавторизованных пользователей.

6. /api/users/delete-self - эндпоинт для удаления своего аккаунта, информация о пользователе достается из access-токена

7. /api/books/add-book - энпоинт для добавления книги в общую библиотеку. Защищенность этой ручки обусловлена мерами безопасности, чтобы неавторизованный пользователь не мог как-то работать с данными, также связана с дополнительной фичей.

8. /api/books/update-book - энпоинт для обновления информации о книге с определенным id. Защищен от неавторизованных пользователей.

9. /api/books/delete-book - эндпоинт для удаления книги с определенным id. Защищен от неавторизованных пользователей.

10. /api/business/lending-book - эндпоинт для выдачи определенной книги пользователю. Защищен т.к. книга выдается только текущему авторизованному пользователю, id пользователя подтягивается из access-токена и пользователю с этим id выдается книга.

11. /api/business/return-book - эндпоинт для возврата книги по определенному borrowed_id (id записи из смежной таблицы borrowed_books). Защищен т.к. книга возвращается текущим авторизованным пользователем, id пользователя подтягивается из access-токена и пользователь с этим id возвращает книгу.

## Как реализована аутентификация/авторизация?
В эндпоинте /api/auth/register происходит создание пользователя, задаются его имя, почта и пароль(минимальную и максимальную длину пароля можно задать в config.py).

Далее в эндпоинте /api/auth/login можно ввести данные существующего пользователя. 

Затем ищется запись с заданной почтой в таблице users, если запись с заданной почтой не найдена, то выбрасывается ошибка, иначе сравнивается хэш пароля, лежащего в базе данных с введенным паролем с помощью библиотеки bcrypt. Если пароли совпадают, то на основе полученной записи пользователя генерируется access-токен с данными и refresh-токен, который в payload содержит только id пользователя. Эти токены отдаются пользователю в теле ответа.

После этого в документации Swagger справа сверху надо нажать Authorize и в пункте HTTPBearer вставить либо access-токен, либо refresh-токен.

    ВНИМАНИЕ: Время жизни access-токена по умолчанию 15 минут, а время жизни refresh-токена 30 дней. Вы можете поменять эти данные в config.py

После вставки access-токена вы сможете обращаться ко все защищенным эндпоинтам, кроме /api/auth/refresh, который требует refresh-токен.

# С какими сложностями столкнулся?
В процессе разработки я столкнулся с нетривильной проблемой: пофиксить баг, связанный с удалением книги и каскадным удалением записи из borrowed_books.

## Суть проблемы: 
При удалении книги, id которой совпадало с полем borrowed_books.reader_id из таблицы borrowed_books, вело к удалению этой записи из borrowed_books даже если id удаляемой книги не совпадало с borrowed_books.book_id.

## Как я понял проблему:
При удалении объекта книги из таблицы books, я делал это в защищенном эндпоинте, в котором одной из зависимостью был объект пользователя(из таблицы users) из зависимости get_current_active_auth_user, а FastAPI кэширует результаты в рамках одного запроса(т.е. в get_current_active_auth_user и в delete_book_by_id используется один и тот же объект сессии.), т.о. в сессию пробрасывался так же объект этого пользователя.
При этом в обеих таблицах users и books у поля borrowed_books стоял параметр cascade = "delete-orphan", т.е. "удалить осиротевших". При авторизации пользователя (зависимость Depends(get_current_active_auth_user)) идет в базу данных через функцию get_user_by_id, которая не подгружает данные о borrowed_books и тем самым опция delete-orphan удаляет все "осиротевшие"(которые не нашла в user.borrowed_books) записи из borrowed_books.

## Решение:
Убрал из таблицы users у поля borrowed_books опцию delete-orphan

# Идея для дополнительной фичи
## Реализация системы ролей (обычный пользователь/писатель/админ)
Можно заметить, что некоторые эндпоинты по типу /delete-user, /delete-book и update-book реализованы так, что любой пользователь может удалить другого пользователя, удалить любую книгу или обновить информацию о любой книге. 

Что бы это исправить можно добавить систему ролей. Т.е. чтобы обычный пользователь мог только брать книгу и возвращать ее, писатель мог добавлять книгу и редактировать/удалять только свою книгу, а админ имел доступ ко всем этим эндпоинтам.

## Концептуальная реализация.
1. При регистрации пользователя добавить поле role, которая будет содержать одну из трех ролей. 

2. При входе пользователя зашивать в access-токен информацию о роли.

3. В определенных энпоинтах добавить проверку поля "role" в расшифрованном токене на соответствие роли